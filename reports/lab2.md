# rCore-2023s-lab2 实验报告

## 实现的功能
本章引入了地址空间这一机制，因此需要完成的系统调用不仅包括新的mmap和munmap，还需要对之前的get_taskinfo和get_time系统调用进行重新的调整使得其在本章的os环境下也能够使用。
+ 对于前两个系统调用的升级调整比较简单，主要是需要将应用程序传上来的用户地址空间中的虚拟地址在用户程序的页表中进行一次映射，得到最终的物理地址，然后将相应的数据赋值到该物理地址上即可。
+ 而对于后面的两个系统调用，mmap和munmap，实现虚拟内存映射的创建和撤销。大致思路为：先检查输入的起始地址是否合法，如果是mmap的话还需要检查输入的权限是否合法，然后需要实现并调用相应的接口。从syscall中的mmap/munmap到task中TASK_MANAGER的current_mmap/munmap再到具体当前任务的地址空间MemorySet中进行具体的处理。
    + 对于mmap，先查询当前地址空间是否存在一个MapArea和要创建的区域存在交集。如果有则，返回创建失败；否则开始创建虚拟内存映射，并返回创建虚拟内存映射成功。
    + 对于munmap，主要是查询当前地址空间中是否确实存在一个与要删除的虚拟内存映射相同的MapArea，如果有，则删除并返回删除成功；否则返回删除失败。（这里可能和实际情况还有比较大的差别，有可能要删除的虚拟内存映射跨越好多个MapArea，也有可能在其中会有一些并没有分配出去的内存空间，这里只判断是否全一样，是极大的简化了问题）

## 实验练习题回答

（1）在SV39分页硬件机制中，一个虚拟地址VA占39位（其中虚拟页号VPN占27位，即3*9位），一个实际物理地址PA占56位（其中物理页号占44位），因此理论上一个应用的虚拟地址空间大小为512GB = 2^39 B。页表中页表项的组成及其作用包括：

+ 三个PPN[0:2]标志了该页表项所指向的物理页号，所指向的有可能是下一级页表，也有可能是所要查找的最终目标数据的物理页号。另外的一些标志位的相关作用如下：
+ V： 合法位，仅当该位为1，该页表项对应的虚拟页面才是合法的；
+ R\W\X：读/写/执行的权限位，控制索引到这个页表项的对应的虚拟页面是否允许读/写/执行；
+ U：控制索引到这个页表项对应的虚拟页面是否在U态下可访问；
+ A：access位，表示页表项对应的虚拟页面在最近是否被访问过；
+ D：dirty位，表示页表项对应的虚拟页面是否在最近被修改过。

在SV39分页硬件机制中，一页的大小为4KB（2^12）。而一个页表项所占的字节为8字节，则对于某一级页表中的一页，可以容纳下的页表项（或是下一级页表的物理页号，或者所要查找的最终目标数据的物理页号）的个数为4k/8 = 512 = 2 ^ 9，正好可以放下一个虚拟页号的三分之一：也就是说，在一个字典树结构下，一个虚拟页号需要分三次也只需要分三次就可以完全解析出来对应的物理页号，再加上页偏移量，我们就能够找到最后目标数据所在的物理位置。这也是我所认为的SV39分页硬件机制比较核心的的设计点。

（2）有关缺页的相关问题

+ 缺页机制可能会导致如下异常：
    + 当初次使用一段数据页时，一般会产生缺页异常，系统需要将该页从硬盘中调入内存；
    + 在内存空间使用比较繁忙时，有可能原来使用过的页被换回了硬盘，此时需要触发缺页异常，向内存调入所需页。
+ 发生缺页时，比较重要的寄存器有：
    + 首先是与trap相关的寄存器，包括`sstatus`, `sepc`, `sscratch`等，记录了CPU执行应用程发生trap时CPU状态，trap返回后的下一条指令地址，内核栈或用户栈的栈顶指针等。
    + 其次是和虚拟地址空间相关的寄存器，其中`stval`寄存器会被硬件自动设置为发生错误的虚拟地址，`satp`会被用于内核地址空间和用户地址空间的切换。
+ 使用Lazy策略，直到内存页面被访问才实际进行页表操作，这样做的好处包括：
    + 采用Lazy策略的的效果一定不会比直接加载策略慢，能够提升性能，避免无用的加载。
+ 处理10GB连续的内存页面，对应的SV39页表大致占用空间为：
    + 10GB需要采用三级页表，10GB，其中一个页表项（8字节）所能表示的页帧大小为4KB，所以共需最低级页表项10G / 4K = 2.5M 项，共需最低级页表内存大小为2.5M * 8B = 20MB，第二级和第三级页表所需内存同理可算得大致为40KB和8B。
+ 在mmap中引入Lazy策略：
    + 可以在地址空间管理`MemorySet`中加入一个已申请映射但还从未使用的虚拟地址页集合`UnusedPage`。当需要使用某个虚拟地址时，如果在已有的页表中查找没有找到，就转向在`UnusedPage`中查找是否已经创建映射了：如果确实存在映射，那就立即申请一块物理页帧并填充页表；如果没有存在映射，那就返回访址错误。

+ 使用swap策略的缺页异常，内存中的页被换到硬盘上，体现在页表项中为：
    + 对应的A(access)位的值会变为0，表示该页最近没有被访问过，很有可能已经被换出内存了。

（3）有关单页表和双页表的问题

+ 在单页表情况下的页表切换：
    + 当应用程序没有发生线程切换时，不需要进行页表切换，因为该应用程序线程和其内核线程共用同一张页表；
    + 当发生线程切换时，需要用换入线程的页表地址按照`satp CSR` 格式要求构造64位整数，赋值给`satp`寄存器。
+ 在单页表情况下，如何控制用户态无法访问内核页面：
    + 将内核页面对应的页表项的U标志位设为0
+ 单页表有何优势：
    + 不需要像双页表一样在内核和用户态转换时切换页表，也不需要跳板，可以像没引入虚拟地址空间一样直接进行上下文切换
+ 双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表：
    + 双页表实现下：切换页表发生在用户程序和内核切换时；
    + 单页表实现下：在不同用户线程进行切换时。



## 荣誉准则
1. 在完成本次实验的过程（含此前学习的过程）中，我参考过微信群内有关git仓库提交的的相关事项，但并没有与他人做过交流。
2. 此外，我也参考了以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：
[rust中alloc::BtreeMap的相关用法](https://doc.rust-lang.org/alloc/collections/btree_map/struct.BTreeMap.html#method.get_key_value)

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。