# rCore-2023s-lab1实验报告

## 实现的功能
本章的编程作业是实现一个获取任务信息的系统调用。执行时间和运行状态都比较好做，这里就不介绍了。在系统调用计数方面，由于我第一次实现这个系统调用时是直接在任务控制块中加入一个长度为MAX_SYSCALL_NUM的数组，然后会产生内存问题。于是我在这次的实现中，我利用了已经实现好的基于伙伴系统的动态分配器，在任务控制块中加入了BTreeMap来存储系统调用次数，但相对应的，需要将任务全局管理器的tasks字段变成Vector类型。(否则会出现clone()无法实现的问题)然后我修改了任务全局管理器的初始化，加入了两个方法get_task_info和increase_syscall_time，成功实现了获取任务信息的系统调用。


## 问答题
回答：
1. 所使用的sbi版本：RustSBI version 0.3.0-alpha.2, adapting to RISC-V SBI v1.0.0
    三个程序的报错分别为：
    + 使用的地址（0x0）有问题，调用了非法地址，被内核发现，终止了程序。
    + 使用的指令（`sret`）不是该特权级所能使用的，被内核发现，终止了程序。
    + 使用的寄存器（`sstatus`）不是该特权级所能使用的，被内核发现，终止了程序。
2. 
    1. 刚进入`__restore`时，a0表示CPU即将要转为U态所运行的程序的上下文的内存地址。`__restore`的两种使用情景分别为：某个程序在进入S态前还没有执行，需要通过`__restore`进入U态开始执行；某个程序在进入S态前就在执行了，进入S态处理完Trap事件后，需要通过`__restore`回到U态继续执行。
    2. 存储了`sstatus`, `sepc`, `sscratch`, 三个寄存器，分别表示发生Trap之前的CPU信息，Trap异常事件处理返回后应用程序运行的第一条指令和用户栈的栈顶地址。
    3. x2是sp，此时里面的值表示内核栈栈顶，我们在保存其他寄存器时，仍需要用到它，所以我们在保存完所有其他寄存器后再保存x2；而我们不保存x4是因为应用在运行过程中用不到x4，所以不需要我们保存。
    4. 在此条指令执行之后，sp指向用户栈栈顶，sscratch指向内核栈栈顶。
    5. `sret`指令，接收该指令后，硬件自动会将CPU状态降至U态，同时从我们已经通过软件安排好的位置开始执行应用程序。
    6. 在此条指令执行之后，sp指向内核栈栈顶，sscratch指向用户栈栈顶。
    7. 是原应用程序中的系统调用或者发生Trap异常的指令引发的U态转为S态的。


## 荣誉准则
1. 在完成本次实验的过程（含此前学习的过程）中，我没有与他人做过交流，但参考过微信群内有关git仓库提交的的相关事项。
2. 此外，我也参考了以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：
[rust中alloc::BtreeMap的相关用法](https://doc.rust-lang.org/alloc/collections/btree_map/struct.BTreeMap.html#method.get_key_value)

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。